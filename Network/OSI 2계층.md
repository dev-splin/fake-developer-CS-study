# OSI 2계층

---

# 1. 2계층

 

### **2계층(데이터 링크 계층)**

*전기 신호를 우리가 알 수 있는 데이터 형태로 처리하는 계층*

- 주소 정보를 정의하고 정확한 주소로 통신이 되도록하는데 초점을 맞춘다.
- 출발지와 도착지 주소를 확인하고 내게 보낸게 맞는지 내가 처리해야하는지를 검사한 뒤 데이터 처리를 수행한다.
- 여러 통신이 한 번에 이뤄지는 것을 구분하기 위한 기능이 정의된다.
- 전기 신호를 모아 데이터 형태로 처리하기에 데이터에 대한 에러 탐지및 수정 역할을 수행한다.

**⇒ 현재 이더넷 기반 네트워크의 2계층에서는 에러를 탐지하는 역할만 한다.**

- 받는 사람이 현재 데이터를 받을 수 있는지 확인하는 작업(Flow control)을 수행해야 한다.

### **Flow Control**

: 보내는 측과 받는 측간의 속도차를 해결하기 위한 기법

![플로_컨트롤](https://user-images.githubusercontent.com/40491724/133880812-e3eb8b04-fd69-4773-89cf-92aff5e3e680.png)

1) 정지-대기(Stop and Wait) : 송신측에서 프레임을 전송한 후 확인응답(ACK)을 받을 때까지 대기하는 방식

2) 슬라이딩 윈도우(Sliding Window) : 송신측에서 수신측의 확인응답을 받기 전에 수신 가능한 범위 내에서 여러 프레임을 전송

### **이더넷이란?**

이더넷은 네트워크를 구성하는 방식 중 한 방법을 뜻한다.

이더넷은 각 기기들이 고유의 MAC주소를 가지고 호스트(전자 기기) 간의 데이터를 주고 받을 수 있는 방식을 쓰고 있다.

![TCPIP_이더넷](https://user-images.githubusercontent.com/40491724/133880823-bf278234-696f-4eda-92c7-5488f168eb94.png)

Ethernet=(Data Link) + (Physical)

**2계층에서 동작하는 네트워크 구성요소**

1. 네트워크 인터페이스 카드
2. 스위치

***2계층에서는 MAC 주소라는 주소 체계가 있다.***

- MAC주소를 보고 통신해야 할 포트를 지정해 내보낼 수 있다.
- 네트워크 인터페이스 카드(NIC)에는 고유 MAC주소가 있어서 이를 이용해 전기신호가 자신에게 들어오는게 맞는지 확인 후 맞을 경우, 상위 계층에서 처리 할 수 있도록 메모리에 적재한다.
- 스위치는 주소 습득과정을 통해 단말이 어떤 MAC주소인지, 연결포트는 무엇인지 알 수 있다.
- 스위치의 필터링과 포워딩 기능으로 불필요한 처리가 감소하면서 이더넷 네트워크 효율성이 크게 향상되어 이더넷 기반 네트워크가 급증하는 계기가 되었다. (토큰 링과 같은 네트워크가 줄어듬.)

### **네트워크 인터페이스 카드의 동작방식**

![NIC_동작방식](https://user-images.githubusercontent.com/40491724/133880838-758045dc-0363-498c-8cbd-667a64dca002.png)

1. 전기 신호를 데이터 형태로 만든다.
2. 목적지 MAC주소와 출발지 MAC주소 확인
3. 네트워크 인터페이스 카드의 MAC주소 확인
4. 두 MAC주소가 맞으면 데이터를 처리하고 아니면 **데이터를 폐기한다.**

**네트워크 인터페이스 카드를 뜻하는 다른 단어**

- 랜 카드
- 물리 네트워크 인터페이스
- 이더넷 카드
- 네트워크 어댑터

---

# 2. 개념 다시 잡고가기

통신의 전체적인 과정을 보기전에 아래 개념을 한 번 다시 잡을 필요가 있다.

## 패킷이란

전송하는 정보의 한 단위

- 패킷은 쉽게 한 묶음이다. 즉 0100100010101110 이런 데이터들을 일정 크기로 잘라서 묶음화 시킨 것이다.
- 패킷을 잘라 보내는 이유는 100MB크기의 데이터를 전송하고자 할때 분할된 형태가아닌 파일 통째로 보냈다고 가정해보자.
- 100MB크기의 파일을 전송도중 잘못된 데이터가 1개만 끼어도 오류가 발생하기 때문에 처음부터 다시 100MB를 전송해야 한다. 이렇게 되면 매우 비효율적일 것입니다.
- 그래서 데이터를 적절한 크기로 분할하여 전송, 수신체크, 전송, 수신체크의 과정을 거치는 것이 더 효율적이다. 수신체크를 하는 과정에서 데이터가 이상하면 그 부분만 다시 재전송을 하면 된다.

## 패킷과 프레임의 차이

- **프레임** : OSI 7 Layer에서 2계층인 DataLink Layer PDU이다. 프레임에는 체크섬, 송수신 호스트의 주소 등을 가지고 있다. 에러 검출 시 재전송을 요구하며 복구 과정을 거친다.
- **패킷** : OSI 7 Layer에서 3계층인 Network Layer의 PDU이다. 네트워크를 통해 전송될 때 L3 스위치, 라우터 등에서 전달하는 전송단위이다.

어쨌든, 프레임이나 패킷이나 둘 다 정보를 넣어서 전달하는 데이터 묶음이라고 보면 된다. 하지만 이 둘의 차이점은 데이터**를 포장하는 법**과 **어디로 정보를 전달하느냐**에 따른 것이다.

## 패킷과 프레임의 차이에 대한 예시

### 1. **프레임**

 프레임은 2계층에서 사용되는 단위이다. 즉, 외부가 아닌 내부 네트워크에서 사용된다고 생각하면 된다. 그래서 전제 조건은 당연히 내부에서 사용하는 것이므로, Destination Address, Source Address는 MAC주소가 대상이란 것을 인식할 수 있다. 그래서 프레임이라는 데이터를 외부 네트워크로 보내기 위해서는 또 다른 상자에 넣고 전달할 목적지 주소(IP)를 적어야 한다.

- 즉, 이더넷 프레임은 데이터를 담는 컨테이너로 동일 네트워크 상의 정보만 가지고 있다. 이것을 페이로드라고 한다.
- 프레임은 TCP/IP 2계층에서 NIC에서 생성되며 페이로드 크기는 전송되는 데이터 종류에 따라 다르다. 프레임은 네트워크 상으로 전송되고 L2 스위치가 프레임 목적지 주소를 ARP Table을 참조하여 해당 목적지가 어느 포트인지 알려준다.
- L2 스위치는 ARP Table 을 참조하여 확인된 물리 포트로 전달을 한다. 만일 목적지 디바이스에 직접 연결되어 있으면 바로 완료가 된다. 하지만 또 다른 스위치로 연결되어 있다면 그 연결된 스위치의 ARP Table을 참조하여 전달하는 과정을 전달이 완료될 때 까지 반복하게 된다.

### 2. 패킷

- 프레임을 다른 네트워크로 전달을 하기 위해서는 다시한번 데이터를 상자에 담아야 하는데 이것이 패킷이다. 패킷은 3계층에서 다루는 내용으로 서로 다른 네트워크간 통신이 가능하도록 라우팅을 해주는 영역이다. 과거에는 라우터를 사용하여 라우팅을 실시하였으나 요즘은 L3 스위치로 그 기능을 대신해 가고 있다.
- 패킷은 3계층에서 생성되며 데이터를 서로 다른 LAN 간에 데이터를 주고 받을 때 사용되는 단위를 말한다. 즉, 패킷은 L3 스위치가 L2 스위치로부터 전달받은 정보를 다른 네트워크에 있는 목적지로 전달한다. 전달받은 해당 네트워크 상의 L2 스위치가 다시 ARP Table을 참조해 목적지로 전달을 하게 되며 이로써 서로 다른 네트워크 간 데이터 전송은 완료된다.

### 정리

 프레임과 패킷에 대해 알아보았다. 정리를 하자만 프레임은 L2 영역에서의 전송 단위로 보면 되고 패킷은 L2에서 또 다른 L2로 전달을 할 경우 중간에 L3 구간을 거치데 되는데 바로 L3 구간에서 전달되는 데이터의 단위라고 보면 되겠다.

![이더넷_프레임구조](https://user-images.githubusercontent.com/40491724/133880966-c28e03db-c8c7-4019-9187-122b033b6da8.png)

위의 사진을 보면 전체적인 흐름이 어떻게 이어지는 지 감이 잡힐 것 같다.

우선 맨 위의 2계층 이더넷 헤더 구조를 살펴보자.

- MAC 목적지 주소
- MAC 소스(출발) 주소
- **Ethernet Type**
- DATA
- CRC

여기서 말하고 싶은 것은 Type인데, **이더넷 헤더의 Type**에 따라서 **3계층의 프로토콜**이 지정된다.

- 0800 = IP
- 0806 = ARP

그리고 IP헤더에서 Protocol의 종류에따라 4계층의 프로토콜이 정해진다. (상위 프로토콜 지시자)

### 인캡슐레이션과 디캡슐레이션

![패킷](https://user-images.githubusercontent.com/40491724/133881074-148944f3-282a-4614-abed-e3d1f9749adc.jpg)

**인캡슐레이션**

- 현대 네트워크는 패킷 기반 네트워크로 데이터를 패킷 단위로 나눠서 보내는데 이렇게 함으로써 통신회선 독점을 막고 여러 단말이 동시에 통신 할 수 있게된다.
- 그리고 이렇게 나뉜 패킷에 데이터를 분할해서 넣는 과정을 인캡슐레이션이라 부른다.
- 그리고 이렇게 데이터를 패킷에 담을 때 각 계층별로 자신이 필요한 정보를 헤더에 붙혀넣는데, 4계층→ 3계층 → 2계층으로 내려가면서 필요한 헤더정보를 비트 단위(0 or 1)로 작성한다.
- 그렇기에 데이터 하나를 전송하면 데이터 플로 계층에서만 3개의 헤더정보(4,3,2계층)가 추가된다.

**디캡슐레이션**

- 받는 입장에서는 디캡슐레이션 과정을 수행하는데, 받은 전기 신호를 데이터 형태로 2계층으로 올려보내면 2계층에서는 2계층 헤더에 포함된 정보를 확인하고 목적지가 자신이 맞는지 확인을 한다.
- 그리고 목적지가 맞다면 2계층의 헤더정보는 벗겨내고 내용물을 3계층으로 올려보내고 3계층 4계층도 동일한 과정을 거쳐 데이터를 애플리케이션에 올려보낸다.

즉, 데이터는 상위 계층 → 하위 계층, 하위 계층 → 상위 계층으로 전달되며 각각 계층의 헤더정보는 각 계층끼리 전달된다.

여기서 각 계층별로 헤더에 넣는 정보들은 꽤 많기 때문에 모두 이해하긴 힘들지만, 몇가지 규칙이 있으며 그 중 하나가 헤더에 다음 두 가지 정보가 반드시 포함되야 한다는 점이다.

1. **현재 계층에서 정의하는 정보
:** 4계층의 목적인 큰 데이터를 분할/조립하는데 필요한 패킷의 순서 및 빠진 패킷을 검증하는 정보를 헤더에 적는다. TCP/IP 의 4계층인 TCP에서는 시퀀스와 애크번호 필드로 이 데이터를 표현한다.

1. **상위 프로토콜 지시자
:** 프로토콜 계층은 상위 계층으로 올라갈수록 종류가 많아지기 때문에 디캡큘레이션 과정에서 헤더에 상위 프로토콜 지시자가 없으면 어떤 상위 프로토콜로 올려 보내야 할 지 결정할 수 없다.

## 스위치

![Untitled](https://user-images.githubusercontent.com/40491724/133880985-5cd1c97e-6558-4884-ab71-7c4cbefc586d.png)

- 허브와 동일하게 다수의 장비를 연결 및 통신을 중재하는 2계층 장비이다.
- 내부 동작 방식은 다르지만 다수의 장비 연결 및 케이블을 한 곳으로 집중해주는 역할은 동일하기에 허브라는 용어를 공통적으로 사용한다.
- 스위치는 허브의 역할과 통신 중재자라는 2가지 역할을 모두 포함하기에 스위칭 허브로도 불린다.
- 스위치는 MAC주소를 이해할 수 있어 목적지 MAC주소의 위치를 파악 후 목적지까지 연결된 포트로만 전기신호를 보낸다.

![image](https://user-images.githubusercontent.com/40491724/133881003-1c6e125e-3dda-4b61-80da-f40ad9afbf63.png)

- 과거의 효율이 낮고 네트워크 응답 성능을 보장할 수 없던 이더넷 네트워크가 스위치로 인해 효율 및 응답 성능을 보장할 수 있게 되었다.

# 3. ARP

(3계층에 존재하는 프로토콜이라, 패킷단위로 정보를 주고 받는다.)

- ARP는 주소 결정 프로토콜이라고도 부른다.
- ARP(Address Resolution Protocol)은 상대방의 MAC 주소를 알아내기 위해 사용되는 프로토콜이다.
- 이 ARP라는 프로토콜이 어디서 왜 사용되는지 알기 위해선 우선 OSI 7 계층 중 2, 3계층에 대해서 알 필요가 있다. 2, 3계층은 각각 주소를 가지고 있어서 통신할 때 목적지를 찾아 갈 수 있게 해준다.
- 여기서 2계층의 MAC주소는 하드웨어 생산업체에서 임의적으로 할당한 주소이다. 그러기에 하드웨어인 NIC(Network Interface Card)에 종속되있다. 그리고 3계층 IP주소는 우리가 직접 할당하거나 DHCP를 이용해 자동으로 할당받는데 실제 통신에서는 IP주소 기반으로 통신을 하게된다.
- MAC주소는 상대방의 주소를 자동으로 알아내 통신하게 되는데 이 때 **상대방의 MAC 주소를 자동으로 알아내기 위해 사용되는 프로토콜이 바로 ARP**다
- 즉, IP주소를 기반으로 ARP를 통해 MAC 주소를 알아내는 역할을 하고, **캡슐화하는 용도로 사용된다**.  (캡슐화를 시도하게 되면 4계층 → 3계층 →2계층으로 헤더 정보가 붙으며 내려갈 것인데, 2계층의 MAC주소를 알아야 캡슐화를 시킬 수 있다.)

![ARP_프로토콜_필드](https://user-images.githubusercontent.com/40491724/133881018-b5400d2c-0a60-48a8-8889-362c5c51d55b.png)

위 표는 ARP 프로토콜 포맷이다. 보시다시피 2계층과 3계층 정보가 모두 포함되어있는데, 아까도 말했지만 IP 주소 체계와 MAC 주소 체계는 연관성이 없다. 그렇기 때문에 이 두 개의 주소 체계를 연계시켜주기 위한 메커니즘이 ARP이고 그렇기에 위 표와 같이 ARP 프로토콜 필드에는 2계층과 3계층 정보를 같이 포함하는 것이다.

**최초로 통신을 시도할 때는 패킷을 바로 캡슐화(Encapsulation)할 수 없다.**

 어째서일까? 그 이유는 호스트에서 출발지와 목적지 IP주소는 미리 파악이 가능하지만 상대방의 MAC주소를 알 수 없기 때문인데,  상대방의 MAC 주소를 알아내기 위해서는 ARP 브로드캐스트 를 이용해서 네트워크 전체에 상대방의 MAC 주소를 물어봐서 알아내야 한다.

ARP 브로드캐스트를 받은 목적지는 ARP 프로토콜로 자신의 MAC 주소를 응답하는데, 이 작업이 완료되면 이제 부족했던 정보인 목적지의 MAC 주소도 알아냈기에 패킷은 정상적으로 인캡슐레이션되어 상대방에게 전달 될 수 있다.

### **목적지 MAC 주소를 매번 ARP 브로드캐스트를 통해 알아내야 할까?**

- 최초 통신이 목적지 IP를 알아도 MAC주소를 모르기에 ARP 브로드캐스팅을 통해 네트워크 전체에 물어보고 알아와야 한다.
- 그러나, 이렇게 매번 브로드캐스팅을 통해 물어보는 것은 비용낭비가 있다.
- 그래서 IP주소와 MAC 주소를 1:1로 대응하여 테이블로 저장해두는데 이를 **ARP Table**이라 한다.
- 다음은 cmd에 arp -a 라는 명령을 입력한 경우인데 자신의 컴퓨터의 ARP Table이 나오는것을 확인할 수 있다.

![Untitled 1](https://user-images.githubusercontent.com/40491724/133881050-5f49beef-9656-48ba-afbd-51dd4895b24e.png)

- 성능을 위해서는 ARP 테이블이 한 번 생성되면 오래 유지될수록 좋다.
- 논리 주소는 언제든지 바뀔 수 있기 때문에 일정 시간 이상 통신이 없으면 이 테이블은 삭제된다.
- 네트워크 장비에서 ARP 작업은 CPU에서 직접수행하기에 짧은 시간에 많은 ARP요청이 들어오면 네트워크 장비에는 큰 부하가 걸린다. 이를 해결하기 위해 다음과 같은 방법들을 사용한다.

⇒ ARP 테이블 저장 기간을 일반 PC보다 길게 설정
⇒ 많은 ARP 요청이 들어오면 필터링하거나 천천히 처리한다.
⇒ ARP 테이블을 수동으로만 갱신하도록 설정해 운영한다.

- 이외에도 DNS캐시나 라우팅 캐시와 같이 다양한 계층에서 네트워크의 성능을 높이기 위한 캐시 테이블을 가지고 있다.

## ARP의 동작

[https://catsbi.oopy.io/eec728e7-0a31-4c96-9d33-20421bd5e6b3](https://www.notion.so/eec728e70a314c969d3320421bd5e6b3)

이 부분은 캐츠비님의 정리가 너무 잘되어있기 때문에 내용을 옮겨오지 않았습니다.

---

# **데이터 링크 계층의 주요 4가지 기능**

### 1. **Service to neighbors(Service to neighbor layer).**

- 이웃한 계층들에게 잘 정의된 서비스 인터페이스를 제공해 주는 것. (1계층과 3계층에 인터페이스를 제공)
- 주로 확인되지 않은 비연결형 서비스(Unacknowledged connectionless serviece), 확인된 비연결형 서비스(Acknowledged connectionless service), 확인된 연결형기반 서비스(Acknowledged connection-oriented service), 이 세가지 서비스를 제공한다.

### 2. **Framing**

- 데이터 링크 계층이 네트워크 계층에 서비스를 제공하기 위해서는 물리 계층에서 제공하는 서비스를 이용해야 한다. 하지만 물리 계층이 제공하는 비트 스트림(bit stream)은 오류가 존재할 수 있다. (비트의 수가 다르거나, 다른 값을 가지거나)
- 따라서 데이터 링크는 이러한 오류를 찾아내고 필요한 경우 수정하는 기능을 해야 한다. 그렇게 하기 위해서 2계층에서는 데이터를 프레임(frame)으로 그룹화하여 전송하기 위해 **프레이밍을 수행한다.** 즉, 프레이밍이란 물리계층에 의해 제공된 비트 스트림을 분리된 프레임으로 나누는 것 이다.
- 그리고 각 프레임에 대해 체크섬(checksum)을 계산한다. 그리고 프레임이 목적지에 도달하였을 때 그 체크섬은 다시 계산된다. 만약 새롭게 계산된 체크섬이 사전에 프레임에 기록되어 있는 프레임과 다르다면 데이터 링크 계층은 오류가 발생함을 알 수 있고 이를 수정하는 과정을 가진다.

### 3. **흐름 제어(Flow control)**

- 데이터를 보내는 측과 받는 측간의 속도를 확인하여 이를 제어하는 것이다.
- 데이터를 보내는 측의 속도가 상대적으로 빠를 때, 전송에 오류가 없다고 하더라도 특정 시점에서 수신하는 측은 프레임이 도착하자마자 처리할 수 있는 능력이 되지 않아서 일부 프레임을 손실하게 된다.
- 따라서 데이터 링크 계층은 데이터를 받는 측이 속도가 느릴때 빠르게 데이터를 전송하는 측에 의해서 막히지 않도록 속도를 규제한다.

**마지막 네번째는 오류 제어(Error control)입니다.**

- 모든 프레임이 최종 목적지에 올바른 순서로 전달되었는지 확인하여 전송된 오류를 처리하는 것이다.
- 미확인된 비연결형 서비스에서는 오류 제어가 문제되지 않겠지만 확인된 연결지향형 서비스에서는 문제가 될 것이다.
- 따라서 오류를 검출하고 수정하는 기능이 필요하다. 오류 검출 코드는 단지 전송중에 발생한 오류의 존재 여부만을 수신측이 알 수 있도록 하는 코드로써, 패리티검사(Parity check), 검사합(Checksum), 순환중복검사(Cyclic Redundancy Code) 등이 있다.
- 오류 수정 코드는 무엇이 잘못되었는가를 충분히 알 수 있는 여분의 정보를 포함시켜 수신측이 직접 오류를 고칠 수 있게하는 코드로써, 부호어(codeword), 해밍 부호(Hamming code) 등이 있다.

---

### 출처

[https://catsbi.oopy.io/3560cc42-31a6-4165-a973-34e8a714fa91](https://www.notion.so/3560cc4231a64165a97334e8a714fa91)

[https://catsbi.oopy.io/75315c4f-20d7-4196-a239-363f374f7727](https://www.notion.so/75315c4f20d74196a239363f374f7727)

[https://jhnyang.tistory.com/403](https://jhnyang.tistory.com/403)

[https://security-nanglam.tistory.com/192](https://security-nanglam.tistory.com/192)

[https://valueelectronic.tistory.com/89](https://valueelectronic.tistory.com/89)

[https://ict-story.tistory.com/39](https://ict-story.tistory.com/39)

[https://jennana.tistory.com/2](https://jennana.tistory.com/2)

[https://run-it.tistory.com/18](https://run-it.tistory.com/18)