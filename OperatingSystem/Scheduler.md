



# **스케줄러**

## 스케줄링을 설명하기 위한 목차

1. 스케줄링의 의미
2. 프로세스의 상태
3. 프로세스를 스케줄링 하기 위한 큐
4. 스케줄러의 종류
5. 단기 스케줄러 (CPU 스케줄러) // 다음시간에

## 1. **스케줄링이란?**

**Update**

~~프로세스가 생성되어 실행될 때 필요한 시스템의 여러자원을 해당 프로세스에게 할당하는 작업을 의미~~

=> 스케줄링이란 Ready Queue에 존재하는 프로세스들을 특정한 우선순위를 기반으로 CPU를 할당받게 하는 것입니다.

: 예전 장기스케줄러를 사용할 때는 디스크 -> 메모리로 보내는 과정에서 장기스케줄러가 필요해서 자원할당이라고 뭉뜽그려서 설명해놓았는데 요즘은 장기스케줄러를 사용하지 않고, **단기 스케줄러만 사용되기에** CPU 사용의 조율의 관점에서 보는게 더 맞는 것 같아 수정하였다.



하지만 이 챕터에서는 전체적인 스케줄러에 대한 흐름을 이해하기 위한 목적도 있다. 이를 위해 장기, 단기, 중기 스케줄러를 설명하기 위하여 다음과 같이 설명을 이어나가겠다.

1. 프로세스가 생성되어 실행될 때 필요한 시스템의 여러자원을 해당 프로세스에게 할당하는 작업을 의미
2. 프로세스가 생성되어 완료될 때 까지 프로세스는 여러 종류의 스케줄링 과정을 거치게 된다.
3. 예전 스케줄러의 종류에는  장기 스케줄러, 중기 스케줄러, 단기 스케줄러가 있었다.

## 2. **프로세스 상태**

 프로세스의 상태는 프로세스가 생성되고 끝날 때까지 계속해서 바뀌는데, 그 이유로는 I/O 요청, ISR(Interrupt Service Routine), 프로세스 스케줄링 알고리즘 등등이 있다.

**프로세스 상태 모델**

- Two-State Process Model
- Five-State Process Model
- Seven-State Process Model

보통 Five-State모델로 설명되어 있다.

![five-state-model](https://user-images.githubusercontent.com/40491724/122676600-b81f3380-d219-11eb-873f-94f3dc92cef6.png)

1. **New**
: 지금 막 생성되었지만, 운영체제에 의해 수행 가능한 프로세스 풀(pool)로의 진입이 아직 허용되지 않은 프로세스. 전형적으로, 새로운 프로세스는 자신의 프로세스 제어블록(PCB)이 생성되었다 할지라도 그 당시까지 주기억장치에 적재되지는 않는다.

2. **Ready**
: 기회가 주어지면 수행될 준비가 되어 있는 프로세스. (CPU를 할당해주면 바로 실행할 수 있는 단계)

3. **Running**
: 현재 수행 중인 프로세스. (프로세스가 CPU를 차지하고 있는 상태.)

4. **Blocked
:** 입출력 연산 완료 등과 같은 어떤 이벤트가 발생할 때까지 수행될 수 없는 프로세스. 즉, 프로세스가 자원을 요구했는데도 기다려야 한다면 블록상태로 전이가 발생한다.
ex) 
다른 프로세스에 의해 제공될 데이터를 기다리는 경우, 입출력 연산 완료, 다른 프로세스로 부터 메시지를 기다릴 때.

5. **Exit (terminated)**
: 프로세스 수행이 중지(halt)되거나 어떤 이유로 중단(abort)되었기 때문에 운영체제에 의해 수행가능 프로세스 풀에서 방출된 프로세스. **이 때 프로세스가 할당받았던 자원을 반납하게 되어  Exit상태에서도 처리 시간이 걸린다.**

**즉, Running, Blocked, Ready가 번갈아가며 프로세스가 수행이 된다.**

**그래서 뭐가 스케줄링이랑 연관되어 있는데?**

- Ready → Running으로 전이되는 과정
- ready상태에 있는 프로세스들은 한 개가 아니라 여러개이다. 그래서, 그 중에 하나 수행될 프로세스를 고르는 작업을 **스케줄링**이라고 한다.

**조금만 더 나눠보자**

- 프로세스를 고르는 작업을 스케줄링이라 한다. (Ready Queue 중에 실행되기를 기다리는 프로세스를 선택하는 것)
- 고른 프로세스를 CPU에 올리는 것을 dispatch라고 한다.

⇒ 결국 둘을 합쳐서 넓은 의미로 스케줄링이라고 한다.

---

## 3. 프로세스를 스케줄링 하기 위한 큐의 종류

 멀티 프로그래밍 환경에서는 여러개의 프로세스를 사용하기 때문에 이런 프로세스들을 관리하기 위한 자료구조가 필요하다.

이런 자료구조에는 작업 큐(Job Queue), 준비 큐(Ready Queue), 장치 큐(Device Queue)가 있다.

**Job Queue(작업 큐)**

: 시스템의 모든 프로세스를 관리하기 위한 큐로 프로세스의 상태와 무관하게 **현재 시스템 내에 있는 모든 프로세스를 관리한다**. 그렇기 때문에 작업큐에 있다고 해서 반드시 메모리를 가지고 있는 것은 아니다.

**Ready Queue(준비 큐)**

: CPU를 할당받기를 기다리고 있는 프로세스들을 관리하여 준비 큐에 있는 프로세스들은 준비 상태에 있게 된다. 여기서 프로세스들을 줄 세우는 방법으로 스케줄링 알고리즘을 사용한다.

+@
Ready 상태에 있는 프로세스들, 즉 **메모리에 load되어있는 프로세스들**이 ready queue에 쌓여있는다. 따라서, ready queue는 메모리에 load되어있는 queue라고 할 수 있다.

**Device Queue or Blocked Queue (장치 큐, 블록 큐)**

: 각각의 장치마다 서비스를 기다리며 줄 서 있는 프로세스들을 관리한다. 장치 큐에 속한 프로세스는 봉쇄 상태(blocked)가 된다. 장치큐에 속한 프로세스들을 blocked 상태에 있다가 해당 장치의 서비스를 받고나서 장치 컨트롤러가 인터럽트를 발생시키면 준비 상태로 바뀌어 Ready Queue로 이동한다.

---

## 4. 스케줄러의 종류

현재는 단기 스케줄러만 남아있음. 하지만 과거에는 스케줄러에 종류가 있었음.

### **장기 스케줄러 (작업 스케줄러, 상위 스케줄러)**

⇒ 어떤 프로세스를 Ready Queue에 넣을래?

**개념설명**

- 작업 스케줄러라고 불리는 이것은 어떤 프로세스를 Ready Queue에 삽입할지를 결정하는 역할을 한다.
- 메모리가 한정되어 있기에 한번에 많은 프로세스들이 메모리에 올라올 경우에는 대용량 메모리에 임시로 저장된다.
- 그래서 이 Pool에 저장되어 있는 프로세스 중 어떤 프로세스에 메모리를 할당하여 Ready Queue로 보낼지 결정하는 역할을 한다.
- 요즘은 바로 프로세스를 Ready Queue에 올리기 때문에 장기 스케줄러는 사용되지 않는다.

**장기 스케줄러가 하는 작업**

- 메모리와 디스크 사이의 스케줄링을 담당.
- 프로세스에 memory(및 각종 리소스)를 할당(admit)
- degree of Multiprogramming 제어(실행중인 프로세스의 수 제어)
- 프로세스의 상태
new -> ready(in memory)

*cf) 메모리에 프로그램이 너무 많이 올라가도, 너무 적게 올라가도 성능이 좋지 않은 것이다. 참고로 time sharing system 에서는 장기 스케줄러가 없다. 그냥 곧바로 메모리에 올라가 ready 상태가 된다.*

### 단기 스케줄러(Short-term scheduler or CPU scheduler or Process scheduler)

⇒ 어떤 프로세스에게 CPU를 할당해줄래?

- CPU 와 메모리 사이의 스케줄링을 담당.
- Ready Queue 에 존재하는 프로세스 중 어떤 프로세스를 running 시킬지 결정.
- 프로세스에 CPU 를 할당(scheduler dispatch)
- 프로세스의 상태
ready -> running -> waiting(blocked) -> ready

### **중기스케줄러(Medium-term scheduler or Swapper)**

**개념**

- CPU가 실행시킬 프로세스가 많아서 성능 하락이 된다고 판단될 때, Swap Out을 통하여 프로세스를 내보냄.
- 메모리로부터 프로세스를 제거하여 degree of Multiprogramming(멀티프로그래밍 정도)를 제어해 조금 더 성능이 좋게 나올 수 있다는 것에 근거하는 것이 핵심.
- 현재는 사용되지 않지만, 이 아이디어가 확장되어 가상 메모리에서 사용되게 됨.

**중기 스케줄러가 하는 작업**

- 여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아냄 (swapping)
- 프로세스에게서 memory 를 deallocate
- degree of Multiprogramming 제어
- 현 시스템에서 메모리에 너무 많은 프로그램이 동시에 올라가는 것을 조절하는 스케줄러.
- 프로세스의 상태
ready -> suspended





---

# 질문정리



### suspended는 무엇인가요?



**Suspended 는 프로세스 수행 자체가 외부에 의해 정지된 상태이다.** 아래 7상태 모델을 보면 조금 더 이해하기 수월할 것이다.



![image](https://user-images.githubusercontent.com/40491724/122676919-07199880-d21b-11eb-96f7-1fa64b91bee1.png)

7-상태 모델은 5-상태 프로세스 모델에서 2가지 상태가 추가 된 것이다.

- Ready Suspend
- Blocked Suspend



**그럼 Suspend의 상태는 왜 추가 된 것인가?**

- 우선 Suspend된 프로세스의 특징은 모두 "하드디스크"에 있다는 것이다. 
- Suspend의 상태가 추가된 이유는 컴퓨터의 메모리의 크기는 한정적이기 때문에 적재될 수 있는 프로세스의 개수에는 한계가 있다. 
- 그래서 느린 입출력 동작으로 인해 대부분의 프로세스가 Blocked상태에서 CPU가 idle인 상태로 있을 수 있다.
- 이럴 때는 차라리 idle상태의 프로세스를 디스크로 스와핑(Swapping)하고, 대기 상태인 프로세스를 메모리에 올리는 것이 좋을 수 있다.



*Swaping : idle상태인 메모리에 있던 프로세스를 디스크로 이동시키고, 디스크에 있던 대기 상태의 프로세스를 메모리에 옮기는 것.