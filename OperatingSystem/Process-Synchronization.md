프로세스는 공유 자원에 동시에 접근하는 경우 접근 순서에 따라 실행의 결과가 달라지는 Race Condition이 발생할 경우 해당 공유 자원 결과가 달라질 수 있다. 
그렇기에 공유 자원에 대한 신뢰도를 높이고자 특별한 규칙을 만들어 **동기화**에 대해 문제가 발생하지 않도록 하여 **무결성**을 유지시키는 것을 프로세스 동기화라 한다.
...

여러 프로세스 접근이 가능한 '''공유 데이터'''에 동시에 여러 프로세스들이 접근했을 때, Write 커넥션의 경우 시간 지연등의 사유로 부정확한 데이터의 쓰임이 발생할 수 있다. 
이러한 이상현상을 배제하고자 동기화라는 개념을 도입하게 되었다.

### Race Condition

---

공유 자원에 대해 여러 프로세스가 동시에 접근을 시도하는 경우 **타이밍** 혹은 **순서** 등이 결과 값에 영향을 줄 수 있는 상태를 의미한다. **일관성**을 해치고 **무결성**을 파괴시킬 수 있다.

### Critical Session

---

OS에서 여러 프로세스가 데이터를 공유하면서 수행될 때, 각 프로세스에서 공유 데이터를 액세스하는 프로그램 코드 부분을 뜻한다. "**공유자원의 독점을 보장**" 해주는 역할을 수행한다.

```jsx
1. P1이 Critical Section 부분을 수행 중이면 다른 모든 프로세스들은 
   그 Critical Section에 접근할 수 없다. -> Mutual Exclusion ( 상호 배제 )
2. Critical Section에 어떠한 Process도 없다면 들어가고자 하는 프로세스를 들어가게 해줘야한다.
   -> Progress ( 진행 )
3. 프로세스가 Critical section에 들어가기 위해 무한정 기다리는 현상 ( = Starvation ) 이 
   있어서는 안된다. 
```

```jsx
do {
	flag[i] = true; // 프로세스를 들어가게 해준다.
	turn = j // 턴을 설정해준다.
	while(flag[j] && turn == j) // 대기 상태

	// critical section
	
	flag[i] = false;
	// 나머지 섹션 ?

} while(1);
```

### 세마포어

---

- 자원의 개수를 의미한다. → 동시에 자원에 접근할 수 있는 허용 가능한 Counter의 개수를 뜻한다.
- 여러 프로세스들에 의해 **공유되는 변수**로 정의된다.
- P(), V() 라는 Atomic한 연산에 의해서만 접근이 가능하다.
1. Busy-wait 방식 

```jsx
P(s) {
	while (s <= 0) do wait // 프로세스가 모두 사용중이라면 대기
	s--; // 자원의 여유가 생기면 자원을 획득
}

V(s) {
	s++; // 자원을 반납한다.
}
```

2. Block - Wakeup 방식 

```jsx
type struct {
	int value; // 세마포어
	struct process *Q; // 대기 큐
}

P(S) {
	// 자원의 개수가 부족하다면 현재 프로세스를 대기 큐에 추가시킨 후, 블락을 통해 suspend 시킨다.
	S.value--;
	if (S.value < 0) {
		// 프로세스를 큐에 추가한다.
		block();
	}
}

V(S) {
	// 다른 프로세스가 작업을 완료해 자원을 증가시킬 때
	// 자원의 수가 없다면 현재 자원을 기다리는 프로세스가 존재 -> 대기 큐에서 프로세스를 꺼내와 깨운다.
	S.value++;
	if(S.value <= 0) {
		// 프로세스를 큐에서 삭제한다.
		wakeup(P);
	}
}
```

**[\] 뮤텍스 ( Mutex )
→ Binary Semaphore와 같은 의미로 볼 수 있다.** 

뮤텍스는 그 자체의 의미로는 Mutual Exclusion 즉 상호 배제인데, Binary Semaphore라는 의미는 자원에 단 하나의 작업만이 접근할 수 있는 세마포어를 의미한다. 

Critical Section을 가진 스레드들의 Running Time이 서로 겹치지 않게 단독으로 실행되게 하면서, 다중 프로세스들의 공유 자원에 대한 접근을 조율하기 위해 lock과 unlock을 사용한다. 

**Semaphore는 동기화 대상이 하나 이상이지만, Mutex는 동기화 대상이 오직 하나뿐이라는 차이가 있다.**

### 모니터

---

세마포어는 다음과 같은 문제점을 갖고 있다. 

1. 코딩 하기가 어렵다. 
2. 해당 데이터의 일괄성을 보장하는 입증이 어렵다. 
3. 잘못 코딩할 경우 시스템에 악영향을 끼칠 수 있다. → 데이터의 무결성을 해치면서 Sync를 맞추기 위해 코딩한 것이 Sync를 과도하게 해칠 수 있다. 

모니터 내에서는 한 번에 하나의 프로세스만 활동이 가능. 따라서 프로그래머가 동기화 제약 조건을 명시적으로든 **코딩할 필요가 없다.** 프로세스가 모니터 안에서 기다릴 수 있도록 Condition Variable( 조건 변수 )를 사용하며, 이러한 조건 변수는 Wait / Signal 연산에 의해서만 접근할 수 있다. 

```jsx
Wait :: 다른 프로세스가 signal 을 보내기 전까지 suspend 되어야 한다. 
Signal :: 딱 '하나의' suspend 된 프로세스를 깨운다. 
```

모니터를 자체적으로 하나의 프로세스만을 처리한다는 장점이 있으며, 
세마포어는 직접 락을 걸고 해제해야 한다라는 단점을 가지고 있다. 

모니터는 뮤텍스의 상위 개념이면서 세마포어와는 결이 다른 느낌으로 이해할 수 있다.

### 질문 답변

Q1. 세마포어와 뮤텍스의 차이는? (보충)

- 세마포어는 공유 자원에 **세마포어의 변수(임계구역내의 자원의 수)만큼의 프로세스(또는 쓰레드)가 접근**할 수 있다. 반면에 뮤텍스는 **오직 1개만의 프로세스(또는 쓰레드)만 접근**할 수 있다. (카운팅 세마포어를 기준으로 설명)
- 현재 수행중인 프로세스가 아닌 **다른 프로세스가 세마포어를 해제할 수 있다.** 하지만 뮤텍스는 **락(lock)을 획득한 프로세스가 반드시 그 락을 해제**해야 한다.



Q2. 뮤텍스, 세마포어, 모니터에 대한 추가 설명 링크

[Operating System : 뮤텍스(Mutex) / 세마포어(Semaphore) / 모니터(Monitor)](https://dev-splin.github.io/cs(computer%20science)/operating%20system/OS-Mutex,Semaphore,Monitor/)
